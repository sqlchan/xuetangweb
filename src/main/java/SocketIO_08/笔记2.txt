学习基于NIO的同步非阻塞式编程

Java1.5之前用伪异步，用的线程池加对列。将客户端的socket封装成一个task任务(实现runnable接口的类)然后投递到线程池中去，配置相应的队列进行实现。

IO和NIO的区别：其本质就是阻塞和非阻塞的区别；
    阻塞概念：应用程序在获取网络数据的时候，如果网络传输数据很慢，程序就一直等着，知道传输完毕为止。
    非阻塞概念：应用程序直接可以获取已经准备就绪好的数据，无需等待。NIO，Java1.7之前只有非阻塞。加载到缓冲区，准备好后发一个信号。

IO为同步阻塞形式，NIO为同步非阻塞形式。NIO并没有实现异步，在Java1.7之后，升级了NIO包，支持异步非阻塞通信模型即NIO2.0
    同步和异步：同步和异步一般是面向操作系统与应用程序对IO操作的层面上来区别的。
    同步时，应用程序会直接参与IO读写，冰球我们的应用程序会直接阻塞到某个方法上，直到数据准备就绪；或者采用轮训的策略实时检查数据的就绪状态，如果就绪则获取数据。
    异步时：则所有的IO读写操作交给操作系统才处理，与我们的应用程序没有直接关系，我们程序不需要关心IO读写，当操作系统完成了IO读写操作是，会给我们应用程序发送通知，程序直接拿走数据即可。

同步说的是你的server服务器端的执行方式
阻塞说的是具体的技术，接收数据的方式、状态IO、NIO

缓冲区Buffer、管道channel、选择区selector
服务端通过selector多路复用器，轮询所有注册的通道，根据通道状态，指行相关操作。客户端将channel注册到服务端的selector上。
client端使用socketchannel，server端使用serversocketchannel，server端创造一个selector多路复用器。selector使用一个线程轮询注册打的通道。通道的状态：connect连接状态，accept阻塞状态，read可读状态，write可写状态。
IO将数据直接写入或读取到stream对象中。在NIO中，所有的数据都是用缓冲区来处理读写的，缓冲区实质是一个数组，提供了位置，容量，上限。
wrap方法的使用，不建议使用，方法包裹一个数组
更好的方式netty
API不好用，netty里的buffer更好用。思想好。NIO编程太麻烦了。